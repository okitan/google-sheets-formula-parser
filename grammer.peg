start 
  = unary_expr / elem

unary_expr
  = head:elem SP? tails:(OPERATOR SP? elem)+ {
    return objects.buildUnaryExpression({ literal: text(), head, tails })
  }

elem 
  = number

//----
// General
//----
SP
  = [' '\t\r\n]+

//----
// Operator
//----

OPERATOR
  = PLUS / MINUS

//----
// Number
//----

number
  = float / integer

// Number core
DIGIT
  = [0-9]

ZERO
  = "0"

NONZERODIGIT
  = [1-9]

PLUS
  = "+"

MINUS
  = "-"

DECIMAL_POINT
  = "."

// integer
integer
  = s:SIGN i:signed_integer  {
    const negative = s.filter((e) => e === "-").length % 2 === 1;
    return { 
      type: "Number",
      literal: text(),
      value: i.value * (negative ? -1 : 1),
      negative
    }
  }

SIGN
  = (PLUS / MINUS)*

signed_integer
  =   ZERO { return new objects.Number(0) } 
    / (NONZERODIGIT DIGIT*) { return new objects.Number(text()) }

// float
frac
  = DECIMAL_POINT DIGIT+ { return new objects.Number(`0${text()}`) }

float
  = i:integer f:frac {
    return {
      type: "Number",
      literal: text(),
      value: i.value + f.value * (i.negative ? -1 : 1)
    }
  } 