start 
  = additive_expr

additive_expr
  = head:multiplicative_expr SP? tails:(ADDITIVE_OPERATOR SP? multiplicative_expr)+ {
      return objects.buildUnaryExpression({ literal: text(), head, tails })
    } 
  / multiplicative_expr

multiplicative_expr
  = head:primary_expr SP? tails:(MULTIPLICATIVE_OPERATOR SP? primary_expr)+ {
      return objects.buildUnaryExpression({ literal: text(), head, tails })
    }
  / primary_expr

primary_expr
  = elem
  / LPAREN SP? e:additive_expr SP? RPAREN { 
    return { ...e, literal: text() };
  }

elem 
  = number

//----
// General
//----
SP
  = [' '\t\r\n]+

LPAREN
  = "("

RPAREN
  = ")"

//----
// Operator
//----

OPERATOR
  = ADDITIVE_OPERATOR

ADDITIVE_OPERATOR
  = PLUS / MINUS

MULTIPLICATIVE_OPERATOR
  = MULTIPLY / DIVIDE

//----
// Number
//----

number
  = float / integer

// Number core
DIGIT
  = [0-9]

ZERO
  = "0"

NONZERODIGIT
  = [1-9]

PLUS
  = "+"

MINUS
  = "-"

MULTIPLY
  = "*"

DIVIDE
  = "/"

DECIMAL_POINT
  = "."

// integer
integer
  = s:SIGN i:signed_integer  {
    const negative = s.filter((e) => e === "-").length % 2 === 1;
    return { 
      type: "Number",
      literal: text(),
      value: i.value * (negative ? -1 : 1),
      negative
    }
  }

SIGN
  = (PLUS / MINUS)*

signed_integer
  = ZERO                  { return new objects.Number("0") } 
  / (NONZERODIGIT DIGIT*) { return new objects.Number(text()) }

// float
float
  = i:integer f:frac {
    return {
      type: "Number",
      literal: text(),
      value: i.value + f.value * (i.negative ? -1 : 1)
    }
  } 

frac
  = DECIMAL_POINT DIGIT+ { return new objects.Number(`0${text()}`) }
