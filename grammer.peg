start 
  = additive_expr

additive_expr
  = head:multiplicative_expr tails:(SP? ADDITIVE_OPERATOR SP? multiplicative_expr)* {
      return objects.buildUnaryExpression({ literal: text(), head, tails })
    } 

multiplicative_expr
  = head:primary_expr tails:(SP? MULTIPLICATIVE_OPERATOR SP? primary_expr)* {
      return objects.buildUnaryExpression({ literal: text(), head, tails })
    }

primary_expr
  = elem
  / LPAREN SP? e:additive_expr SP? RPAREN { 
    return { ...e, literal: text() };
  }

// a1 should be treated first because it involves number
// if named_range is treated first, some a1_notation is considered as named_range
elem 
  = a1_notation / number / string / named_range

//----
// General
//----
SP
  = [' '\t\r\n]+

LPAREN
  = "("

RPAREN
  = ")"

//----
// Number
//----

number
  = float / integer

// Number core
DIGIT
  = ZERO / NONZERO_DIGIT

ZERO
  = "0"

NONZERO_DIGIT
  = [1-9]

PLUS
  = "+"

MINUS
  = "-"

DECIMAL_POINT
  = "."

// integer
integer
  = s:SIGN i:signed_integer  {
    const negative = s.filter((e) => e === "-").length % 2 === 1;
    return objects.Number({ 
      literal: text(),
      value: i.value * (negative ? -1 : 1),
      negative
    })
  }

SIGN
  = (PLUS / MINUS)*

signed_integer
  = (ZERO  / (NONZERO_DIGIT DIGIT*)) { return objects.parseAsNumber(text()) }

// float
float
  = i:integer f:frac {
    return objects.Number({
      literal: text(),
      value: i.value + f.value * (i.negative ? -1 : 1)
    });
  } 

frac
  = DECIMAL_POINT DIGIT+ { return objects.parseAsNumber(`0${text()}`) }

//----
// string
//----

ALPHA 
  = LOWER_ALPHA / UPPER_ALPHA
LOWER_ALPHA 
  = [a-z]
UPPER_ALPHA 
  = [A-Z]

ALNUM = ALPHA / DIGIT

DOUBLE_QUOTE 
  = '"'

// string
// "" means " in DOUBLE_QUOTE
CHAR_FOR_STRING 
  = [^"] 
  / DOUBLE_QUOTE DOUBLE_QUOTE { return `"` }

string 
  = DOUBLE_QUOTE s:CHAR_FOR_STRING* DOUBLE_QUOTE { return objects.String({ literal: text(), value: s.join("") }) }

//----
// cell or range
//----

SINGLE_QUOTE
  = "'"

// '' means ' in SINGLE_QUOTE
CHAR_IN_SINGLE_QUOTE
   = [^']
   / SINGLE_QUOTE SINGLE_QUOTE { return `'` }

// range involves cell
a1_notation 
  = range / cell

DELIMITER
  = ":"

COLUMN
  = [A-Z]+ { return text() }

EXCLAMATION_MARK
  = "!"

ROW
  = NONZERO_DIGIT DIGIT* { return parseInt(text(), 10) }

sheet_name
  = SINGLE_QUOTE s:CHAR_IN_SINGLE_QUOTE+ SINGLE_QUOTE { return s.join("") }

sheet_name_suffix
   = s:sheet_name EXCLAMATION_MARK { return s }
   / s:ALNUM+ EXCLAMATION_MARK { return s.join("") }

cell
  = s:sheet_name_suffix? c:COLUMN r:ROW { return objects.buildNotation({ literal: text(), sheetName: s, startColumn: c, startRow: r}) }

range
  = s:sheet_name_suffix? c1:COLUMN r1:ROW? DELIMITER c2:COLUMN r2:ROW? { return objects.buildNotation({ literal: text(), sheetName: s, startColumn: c1, startRow: r1, endColumn: c2, endRow: r2 }) }
  / s:sheet_name_suffix? c1:COLUMN? r1:ROW DELIMITER c2:COLUMN? r2:ROW { return objects.buildNotation({ literal: text(), sheetName: s, startColumn: c1, startRow: r1, endColumn: c2, endRow: r2 }) }

//----
// symbol
//----
named_range
  = (ALNUM / [\u0080-\uFFFF])+ { return objects.NamedRange({ literal: text(), value: text() }) }

//----
// Operator
//----

OPERATOR
  = ADDITIVE_OPERATOR

ADDITIVE_OPERATOR
  = PLUS / MINUS / AMBASSADOR

MULTIPLICATIVE_OPERATOR
  = MULTIPLY / DIVIDE

MULTIPLY
  = "*"

DIVIDE
  = "/"

AMBASSADOR
  = "&"